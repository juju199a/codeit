# 2. Docker 이미지 & 컨테이너: 코어 빌딩 블록
## 18. 모듈 소개
1. 두 가지 기초 개념
  - 이미지
  - 컨테이너

2. 모듈
  - 사전 빌드 및 커스텀 이미지를 사용하는 방법과 그 차이점이 무엇인지 알아봅니다.
  - 도커 컨테이너를 생성하고
  - 그것을 실행하고 관리하는 방법을 배운다는 거죠.

## 19. 이미지 & 컨테이너: 무엇이며, 왜 사용하는가?
1. 컨테이너
  - 결국 컨테이너는 애플리케이션, 웹사이트, 노드 서버, 
  - 애플리케이션을 실행하는 전체 환경 등,
  - 무엇이든 포함하는 작은 패키지라는 것을 배웠습니다.
  - 즉, 컨테이너에 소프트웨어 실행 유닛이 존재합니다.
  - 결국 그 유닛을 여러분이 실행하는 겁니다.
  
2. `디졸버(dissolver)`
  - 디졸버 개념
  - 이미지는 템플릿, 컨테이너의 블루프린트가 될 것이기 때문이죠.
  - 이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함합니다.
  - 그런 다음 컨테이너가 실행되어 코드를 실행합니다.
  - 그리고 분열, 분리가 있습니다.
  - 그것으로 이 모든 설정 명령과 모든 코드가 포함된 `이미지를 한 번에 생성`할 수 있습니다.
  - 하지만 이 이미지를 사용하여 그를 기반으로 `여러 컨테이너`를 만들 수 있습니다.
  - **중요** `이미지`는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지 입니다.
  - **중요** `컨테이너`는 그러한 이미지의 구체적인 실행 인스턴스입니다.
  - 즉, 우리는 이미지를 기반으로 하는 컨테이너를 실행하는 거죠.
  - 이것이 핵심 기본 개념이며, 도커의 모든 것입니다.
  - 이미지와 컨테이너에서 `이미지`는 `블루프린트`이고,
  - `템플릿`은 코드와 애플리케이션을 포함하며, 
  - `컨테이너`는 실행 애플리케이션이 됩니다.
  - 이는 이미지와 컨테이너로 작업을 시작하는 이 모듈을 통해 더 명확해질 겁니다.

## 외부(사전 빌드된) 이미지의 사용 & 실행
1. `컨테이너 실행`
  - 컨테이너는 이미지를 기반으로 한다고 언급했었죠.
  - 컨테이너를 실행할 수 있도록 이미지를 생성하고, 가져오는 두 가지 방법이 있습니다.
  - 첫 번째 방법은 `이미 존재하는 이미지`를 사용하는 겁니다.

2. Docker Hub[hub.docker.com]
  - node 를 검색
  - 나중에 노드 애플리케이션을 실행할 컨테이너인 
  - `노드 애플리케이션 컨테이너`를 구축하는데 사용할 수 있는
  - 공식 노드 도커 이미지를 찾을 수 있습니다.

3. `노드 이미지`
  - 공식 노드 팀에서 배포, 생성, 유지, 관리합니다.
  - 이제 우리는 이 과정 전반에 걸쳐 
  - 일반적으로 `Docker`로 작업할 때
  - 이러한 `공식 이미지`를 자주 사용합니다.
  - 특히 여기에서 `이미지`와 `컨테이너`를 시작하는데 바로 사용할 수 있습니다.

4. `docker run node`
  - 이 명령은 Docker Hub에서 찾은 
  - 이 노드 이미지를 사용해서 이를 활용하여 
  - `이 이미지를 기반`으로 하는 `컨테이너를 생성`합니다.
  - `컨테이너`는 **실제로 실행 중인 `이미지 인스턴스`**이기 때문이죠.
  - `이미지`는 환경 설정 코드가 포함되며 
  - 이 경우 노드 이미지에는 노드 설치가 포함됩니다.
  - 그런 다음 이미지를 실행하여 애플리케이션을 실행하거나
  - 이 경우 `노드 인터렉티브 쉘`을 간단히 실행할 수 있습니다.

5. 명령어 에러
  - Unable to find image 'node:latest' locally
  - 로컬에 없다.
  - Docker Hub에 있기 때문이죠.
  - 자동으로 Docker Hub에서 이미지를 가져옵니다.
  - Docker Hub에서 최신 노드 이미지를 다운로드하고
  - 로컬 머신에 다운로드가 끝나면 
  - 이 이미지를 `컨테이너로 실행`합니다.
  
6. 격리
  - 기본적으로 `컨테이너`는 주변 환경과 격리되어 있다.
  - 컨테이너 내부에서 실행 중인 `인터렉티브 쉘`이 있다고 해서
  - 이 쉘이 사용자인 우리에게 노출된다는 의미는 아닙니다.

7. `docker ps -a`
  - ps는 프로세스를 나타낸다.
  - -a 는 도커가 생성한 모든 `컨테이너`, 모든 `프로세스`가 표시됩니다.

8. `docker run -it node`
  - 도커에게 컨테이너 내부에서 호스팅 머신으로 
  - 대화형 세션을 노출하고 싶다고 알리는 겁니다.
  - 실제로 기본 노드 명령을 실행할 수 있는 
  - `인터렉티브 노드 터미널에 들어갑니다.

9. 정리
  - 여기 노드가 생성된 컨테이너 내부에서 실행 중이며
  - 추가 플래그를 추가함으로써 터미널로 들어가
  - 컨테이너 및 컨테이너에서 실행 중인 노드와
  - 상호 작용할 수 있다는 겁니다.
  - 여기에서 노드는 우리의 컴퓨터에서 실행되고 있지 않다.

10. 나가기
  - 프로세스를 종료
  - `Control + C`를 두 번 눌른다.
  - `node -v`

11. 이미지
  - 이미지는 배후에서 컨테이너에 필요한 `모든 논리`와 `모든 코드`를 보관하는데 사용되며
  - run 명령을 사용하여 `이미지의 인스턴스`를 만듭니다.
  - 그리고 이것은 이미지를 기반으로 하는 `구체적인 컨테이너`를 생성합니다.

12. 동시에 실행
  - 2개의 컨테이너가 동시에 실행될 수 있음을 알 수 있습니다.
  - 이것이 이미지와 컨테이너의 이면에 있는 아이디어입니다.
  - `컨테이너`는 그 `이미지의 실행 인스턴스`입니다.

## 21. 우리의 목표: NodeJS 앱
1. 자신만의 이미지
  - 일반적으로 이러한 이미지를 기반으로 구축한 다음
  - 자신만의 이미지를 구축합니다.
  - 노드 이미지를 구축한 다음
  - 그 이미지로 특정 노드 JS 코드를 실행할 수 있습니다.

2. 베이스 이미지
  - 일반적으로 공식 베이스 이미지를 가져온 다음
  - 그 위에 코드를 추가하여 그 이미지로 코드를 실행합니다.

3. 시나리오
  - 자신의 이미지로 구축하고자 하는 시나리오 입니다.
  - 노드 이미지를 기반으로 자체 이미지를 빌드해 보도록 하죠.

4. 4개의 파일
  - server.js: 기본 노드 애플리케이션 코드, 
  - 노드 JS로 웹 서버를 시작하고, 포트 80에서 수신 대기하여 
  - 그리고 목표를 저장하기 위한 POST 요청을 처리한 다음

5. `package.json`파일
  - **매우 중요**
  - 여기에서 이 노드 애플리케이션에 대해 설명하며
  - **package.json은 `도커`와 상관 없습니다.**
  - 노드 애플리케이션을 실행하는데 필요한 
  - 다른 써드파티 패키지를 노드에 알려줍니다.
  - 이 경우에는 노드 JS 패키지인 익스프레스 프레임워크입니다.
  - 바디 파서 패키지에서 사용할 수 있습니다.

6. `npm install`
  - npm은 노드 JS와 함께 제공되는 또 다른 도구입니다.
  - 노드를 설치할 때 자동으로 설치되죠.
  - npm install은 필요한 모든 종속성을 다운로드하여 설치합니다.

7. `node server.js`

8. 삭제 
  - node_modules
  - 생성된 노드 모듈 폴더를 실제로 삭제해 보겠습니다.
  - package-lock.json 파일을 모두 삭제

## 22. Dockerfile을 사용하여 자체 이미지 빌드하기
1. Dockerfile
  - 도커에 대한 명령이 포함됩니다.
  - 따라서 자체 이미지에 대한 설정 명령이 포함되어 있습니다.

2. `FROM node`
  - 일반적으로 `FROM` 명령으로 시작합니다.
  - 모두 대문자인 FROM
  - 이를 통해 다른 베이스 이미지에 
  - 여러분의 이미지를 구축할 수 있습니다.
  - `node`는 이미지의 이름
  - 도커 허브 상의 이미지 이름 같은 것으로요.
  - 이 노드 이미지는 지금 도커 허브에 있죠.
  - 실제로 이 도커 허브 이미지를 기반으로 
  - 컨테이너를 처음 실행했을 때
  - 이 이미지가 로컬로 다운로드 및 캐시되었기 때문에 
  - 실제로 이 이미지를 기반으로 컨테이너를 실행한 순간
  - 로컬 머신에도 존재하게 됩니다.
  - 자, 이제 이것은 기본적으로 `로컬 도커 허브 이미지`입니다.
  - 가장 중요한 것은 이게 인식될 것이라는 점입니다.
  - node 라는 이름은 도커가 node라는 이름의 이미지가 존재하며 
  - 그를 찾을 수 있다는 것을 의미하죠.

3. `COPY . /all`
  - 매우 간단한 명령은 `COPY . .` 입니다.
  - 첫 번째 경로는 `컨테이너의 외부`, `이미지의 외부` 경로이며
  - `.` 은 도커에게 기본적으로 Dockerfile이 포함된 동일한 폴더임을 알리는 겁니다.
  - 하지만 도커파일은 제외됩니다.
  - 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야 한다고 도커에게 알리는 겁니다.
  - 두번째 `.`은 그 파일을 저장해야 하는 `이미지 내부의 경로`입니다.
  - 모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 
  - 로컬 머신의 파일 시스템에서 완전히 분리된
  - 자체 내부 파일 시스템이 있습니다.
  - 도커 컨테이너 내부에 숨겨져 있는데요.
  - 실제로 여기에서는 루트 폴더 
  - 즉, 도커 컨테이너의 루트 엔트리를 사용하지 않고
  - 전적으로 사용자가 선택한 서브 폴더를 사용하는 것이 좋습니다.
  - `/app` 이라고 해 보죠.
  - 그리고 이 폴더가 존재하지 않는 경우에는 
  - `이미지`와 `컨테이너`에 생성됩니다.

4. `RUN npm install`
  - 노드 애플리케이션의 모든 종속성을 설치하기 위해 
  - npm install을 실행해야 했습니다.
  - **도커에도 이를 수행할 수 있는 명령어**가 있습니다.
  - 모든 로컬 파일을 이미지에 복사한 후 
  - 이미지에서 명령을 `RUN` 하고 싶다고 알릴 수 있습니다.

5. `WORKDIR /app`
  - 여기에 문제가 있습니다.
  - 디폴트로 이러한 모든 명령은 
  - `도커 컨테이너` 및 `이미지의 작업 디렉토리`에서 실행됩니다.
  - 디폴트로 그 작업 디렉토리는 `컨테이너 파일 시스템의 루트 폴더`입니다.
  - 여기에서 코드를 app폴더에 복사하고 있기 때문에
  - npm install도 app 폴더 내에서 실행하고 싶은데요.
  - 도커에게 모든 명령이 그 폴더에서 실행되어야 한다고 알려주는 편리한 방법은
  - 여기에서 이 명령을 설정하는 것입니다.
  - 이것은 도커 컨테이너의 작업 디렉토리를 설정하는 `WORKDIR`명령인데요.
  - `/app`으로 설정하도록 하죠.
  - 이것은 도커에게 모든 후속 명령이 `그 폴더 내부`에서 실행될 것임을 알리는 겁니다.

6. `COPY . /app`
  - `COPY . ./`
  - `./`는 도커 컨테이너의 현재 작업 디렉토리를 의미하죠.
  - 절대 경로인 `/app`이라고 설정할 수도 있습니다.
  - 이렇게 하면 파일을 복사할 위치를 명확히 알 수 있다.

7. `CMD node server.js`
  - 마지막 명령은 모든 작업이 완료되면 서버를 시작하라는 겁니다.
  - `RUN node server.js`라고 할 수 있지만, 이건 틀린 겁니다.
  - 이 이미지가 빌드될 때마다 실행되기 때문에
  - 이 명령은 올바르지 않습니다.
  - **매우 중요** 여기에 있는 모든 것은 이미지 설정을 위한 도커에 대한 명령입니다.
  - 자, 이미지는 컨테이너의 템플릿이어야 함을 명심하세요.
  - `이미지`를 실행하는 것이 아니라,
  - `이미지를 기반`으로 `컨테이너`를 실행하는 겁니다.
  - 따라서 이 명령을 사용하여 이미지와 템플릿에서 서버를 시작하려고 시도하지만
  - 우리가 원하는 것이 아닙니다.
  - 모든 종속성을 설치하고, 
  - 거기에다 모든 코드를 포함하고 싶습니다.
  - **하지만 이미지를 기반으로 컨테이너를 시작하는 경우에만 서버를 시작하고 싶은 겁니다.**
  - `하나의 동일한 이미지`에서 `여러 컨테이너`를 시작하면
  - 노드 서버도 여러개 시작되죠.
  - 따라서 이를 위한 또 다른 명령이 있습니다.
  - 이는 CMD 명령입니다.

8. `CMD`
  - RUN과의 차이점은 `이미지가 생성`될 때 실행되지 않고 
  - 이미지를 기반으로 컨테이너가 시작될 때 실행된다는 겁니다.
  - 컨테이너가 실행된 후에 노드 서버를 실행하고자 하는 거죠.
  - 그런데 CMD의 경우, 구문이 약간 다릅니다.
  - 우리는 배열을 전달합니다.
  - 명령을 두 개의 문자열로 분할하는데요.
  - 도커에게 이미지를 기반으로 컨테이너가 `시작`될 때마다
  - 그 컨테이너 내부에 있는 node 명령을 사용하여 
  - server.js 파일을 실행하도록 지시합니다.
  
9. `EXPOSE 80`
  - 도커에 알리는 EXPOSE 80 명령을 추가해야 합니다.
  - 이 컨테이너를 실행할 우리의 로컬 머신에게 말이죠.
  - 그런 후에 이 80 포트를 수신하고 있는 그런 컨테이너를 실행할 수 있게 되는 거죠.
  


