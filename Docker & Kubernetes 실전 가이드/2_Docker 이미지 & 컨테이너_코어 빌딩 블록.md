# 2. Docker 이미지 & 컨테이너: 코어 빌딩 블록
## 18. 모듈 소개
1. 두 가지 기초 개념
  - 이미지
  - 컨테이너

2. 모듈
  - 사전 빌드 및 커스텀 이미지를 사용하는 방법과 그 차이점이 무엇인지 알아봅니다.
  - 도커 컨테이너를 생성하고
  - 그것을 실행하고 관리하는 방법을 배운다는 거죠.

## 19. 이미지 & 컨테이너: 무엇이며, 왜 사용하는가?
1. 컨테이너
  - 결국 컨테이너는 애플리케이션, 웹사이트, 노드 서버, 
  - 애플리케이션을 실행하는 전체 환경 등,
  - 무엇이든 포함하는 작은 패키지라는 것을 배웠습니다.
  - 즉, 컨테이너에 소프트웨어 실행 유닛이 존재합니다.
  - 결국 그 유닛을 여러분이 실행하는 겁니다.
  
2. `디졸버(dissolver)`
  - 디졸버 개념
  - 이미지는 템플릿, 컨테이너의 블루프린트가 될 것이기 때문이죠.
  - 이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함합니다.
  - 그런 다음 컨테이너가 실행되어 코드를 실행합니다.
  - 그리고 분열, 분리가 있습니다.
  - 그것으로 이 모든 설정 명령과 모든 코드가 포함된 `이미지를 한 번에 생성`할 수 있습니다.
  - 하지만 이 이미지를 사용하여 그를 기반으로 `여러 컨테이너`를 만들 수 있습니다.
  - **중요** `이미지`는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지 입니다.
  - **중요** `컨테이너`는 그러한 이미지의 구체적인 실행 인스턴스입니다.
  - 즉, 우리는 이미지를 기반으로 하는 컨테이너를 실행하는 거죠.
  - 이것이 핵심 기본 개념이며, 도커의 모든 것입니다.
  - 이미지와 컨테이너에서 `이미지`는 `블루프린트`이고,
  - `템플릿`은 코드와 애플리케이션을 포함하며, 
  - `컨테이너`는 실행 애플리케이션이 됩니다.
  - 이는 이미지와 컨테이너로 작업을 시작하는 이 모듈을 통해 더 명확해질 겁니다.

## 외부(사전 빌드된) 이미지의 사용 & 실행
1. `컨테이너 실행`
  - 컨테이너는 이미지를 기반으로 한다고 언급했었죠.
  - 컨테이너를 실행할 수 있도록 이미지를 생성하고, 가져오는 두 가지 방법이 있습니다.
  - 첫 번째 방법은 `이미 존재하는 이미지`를 사용하는 겁니다.

2. Docker Hub[hub.docker.com]
  - node 를 검색
  - 나중에 노드 애플리케이션을 실행할 컨테이너인 
  - `노드 애플리케이션 컨테이너`를 구축하는데 사용할 수 있는
  - 공식 노드 도커 이미지를 찾을 수 있습니다.

3. `노드 이미지`
  - 공식 노드 팀에서 배포, 생성, 유지, 관리합니다.
  - 이제 우리는 이 과정 전반에 걸쳐 
  - 일반적으로 `Docker`로 작업할 때
  - 이러한 `공식 이미지`를 자주 사용합니다.
  - 특히 여기에서 `이미지`와 `컨테이너`를 시작하는데 바로 사용할 수 있습니다.

4. `docker run node`
  - 이 명령은 Docker Hub에서 찾은 
  - 이 노드 이미지를 사용해서 이를 활용하여 
  - `이 이미지를 기반`으로 하는 `컨테이너를 생성`합니다.
  - `컨테이너`는 **실제로 실행 중인 `이미지 인스턴스`**이기 때문이죠.
  - `이미지`는 환경 설정 코드가 포함되며 
  - 이 경우 노드 이미지에는 노드 설치가 포함됩니다.
  - 그런 다음 이미지를 실행하여 애플리케이션을 실행하거나
  - 이 경우 `노드 인터렉티브 쉘`을 간단히 실행할 수 있습니다.

5. 명령어 에러
  - Unable to find image 'node:latest' locally
  - 로컬에 없다.
  - Docker Hub에 있기 때문이죠.
  - 자동으로 Docker Hub에서 이미지를 가져옵니다.
  - Docker Hub에서 최신 노드 이미지를 다운로드하고
  - 로컬 머신에 다운로드가 끝나면 
  - 이 이미지를 `컨테이너로 실행`합니다.
  
6. 격리
  - 기본적으로 `컨테이너`는 주변 환경과 격리되어 있다.
  - 컨테이너 내부에서 실행 중인 `인터렉티브 쉘`이 있다고 해서
  - 이 쉘이 사용자인 우리에게 노출된다는 의미는 아닙니다.

7. `docker ps -a`
  - ps는 프로세스를 나타낸다.
  - -a 는 도커가 생성한 모든 `컨테이너`, 모든 `프로세스`가 표시됩니다.

8. `docker run -it node`
  - 도커에게 컨테이너 내부에서 호스팅 머신으로 
  - 대화형 세션을 노출하고 싶다고 알리는 겁니다.
  - 실제로 기본 노드 명령을 실행할 수 있는 
  - `인터렉티브 노드 터미널에 들어갑니다.

9. 정리
  - 여기 노드가 생성된 컨테이너 내부에서 실행 중이며
  - 추가 플래그를 추가함으로써 터미널로 들어가
  - 컨테이너 및 컨테이너에서 실행 중인 노드와
  - 상호 작용할 수 있다는 겁니다.
  - 여기에서 노드는 우리의 컴퓨터에서 실행되고 있지 않다.

10. 나가기
  - 프로세스를 종료
  - `Control + C`를 두 번 눌른다.
  - `node -v`

11. 이미지
  - 이미지는 배후에서 컨테이너에 필요한 `모든 논리`와 `모든 코드`를 보관하는데 사용되며
  - run 명령을 사용하여 `이미지의 인스턴스`를 만듭니다.
  - 그리고 이것은 이미지를 기반으로 하는 `구체적인 컨테이너`를 생성합니다.

12. 동시에 실행
  - 2개의 컨테이너가 동시에 실행될 수 있음을 알 수 있습니다.
  - 이것이 이미지와 컨테이너의 이면에 있는 아이디어입니다.
  - `컨테이너`는 그 `이미지의 실행 인스턴스`입니다.

## 21. 우리의 목표: NodeJS 앱
1. 자신만의 이미지
  - 일반적으로 이러한 이미지를 기반으로 구축한 다음
  - 자신만의 이미지를 구축합니다.
  - 노드 이미지를 구축한 다음
  - 그 이미지로 특정 노드 JS 코드를 실행할 수 있습니다.

2. 베이스 이미지
  - 일반적으로 공식 베이스 이미지를 가져온 다음
  - 그 위에 코드를 추가하여 그 이미지로 코드를 실행합니다.

3. 시나리오
  - 자신의 이미지로 구축하고자 하는 시나리오 입니다.
  - 노드 이미지를 기반으로 자체 이미지를 빌드해 보도록 하죠.

4. 4개의 파일
  - server.js: 기본 노드 애플리케이션 코드, 
  - 노드 JS로 웹 서버를 시작하고, 포트 80에서 수신 대기하여 
  - 그리고 목표를 저장하기 위한 POST 요청을 처리한 다음

5. `package.json`파일
  - **매우 중요**
  - 여기에서 이 노드 애플리케이션에 대해 설명하며
  - **package.json은 `도커`와 상관 없습니다.**
  - 노드 애플리케이션을 실행하는데 필요한 
  - 다른 써드파티 패키지를 노드에 알려줍니다.
  - 이 경우에는 노드 JS 패키지인 익스프레스 프레임워크입니다.
  - 바디 파서 패키지에서 사용할 수 있습니다.

6. `npm install`
  - npm은 노드 JS와 함께 제공되는 또 다른 도구입니다.
  - 노드를 설치할 때 자동으로 설치되죠.
  - npm install은 필요한 모든 종속성을 다운로드하여 설치합니다.

7. `node server.js`

8. 삭제 
  - node_modules
  - 생성된 노드 모듈 폴더를 실제로 삭제해 보겠습니다.
  - package-lock.json 파일을 모두 삭제

## 22. Dockerfile을 사용하여 자체 이미지 빌드하기
1. Dockerfile
  - 도커에 대한 명령이 포함됩니다.
  - 따라서 자체 이미지에 대한 설정 명령이 포함되어 있습니다.

2. `FROM node`
  - 일반적으로 `FROM` 명령으로 시작합니다.
  - 모두 대문자인 FROM
  - 이를 통해 다른 베이스 이미지에 
  - 여러분의 이미지를 구축할 수 있습니다.
  - `node`는 이미지의 이름
  - 도커 허브 상의 이미지 이름 같은 것으로요.
  - 이 노드 이미지는 지금 도커 허브에 있죠.
  - 실제로 이 도커 허브 이미지를 기반으로 
  - 컨테이너를 처음 실행했을 때
  - 이 이미지가 로컬로 다운로드 및 캐시되었기 때문에 
  - 실제로 이 이미지를 기반으로 컨테이너를 실행한 순간
  - 로컬 머신에도 존재하게 됩니다.
  - 자, 이제 이것은 기본적으로 `로컬 도커 허브 이미지`입니다.
  - 가장 중요한 것은 이게 인식될 것이라는 점입니다.
  - node 라는 이름은 도커가 node라는 이름의 이미지가 존재하며 
  - 그를 찾을 수 있다는 것을 의미하죠.

3. `COPY . /all`
  - 매우 간단한 명령은 `COPY . .` 입니다.
  - 첫 번째 경로는 `컨테이너의 외부`, `이미지의 외부` 경로이며
  - `.` 은 도커에게 기본적으로 Dockerfile이 포함된 동일한 폴더임을 알리는 겁니다.
  - 하지만 도커파일은 제외됩니다.
  - 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야 한다고 도커에게 알리는 겁니다.
  - 두번째 `.`은 그 파일을 저장해야 하는 `이미지 내부의 경로`입니다.
  - 모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 
  - 로컬 머신의 파일 시스템에서 완전히 분리된
  - 자체 내부 파일 시스템이 있습니다.
  - 도커 컨테이너 내부에 숨겨져 있는데요.
  - 실제로 여기에서는 루트 폴더 
  - 즉, 도커 컨테이너의 루트 엔트리를 사용하지 않고
  - 전적으로 사용자가 선택한 서브 폴더를 사용하는 것이 좋습니다.
  - `/app` 이라고 해 보죠.
  - 그리고 이 폴더가 존재하지 않는 경우에는 
  - `이미지`와 `컨테이너`에 생성됩니다.

4. `RUN npm install`
  - 노드 애플리케이션의 모든 종속성을 설치하기 위해 
  - npm install을 실행해야 했습니다.
  - **도커에도 이를 수행할 수 있는 명령어**가 있습니다.
  - 모든 로컬 파일을 이미지에 복사한 후 
  - 이미지에서 명령을 `RUN` 하고 싶다고 알릴 수 있습니다.

5. `WORKDIR /app`
  - 여기에 문제가 있습니다.
  - 디폴트로 이러한 모든 명령은 
  - `도커 컨테이너` 및 `이미지의 작업 디렉토리`에서 실행됩니다.
  - 디폴트로 그 작업 디렉토리는 `컨테이너 파일 시스템의 루트 폴더`입니다.
  - 여기에서 코드를 app폴더에 복사하고 있기 때문에
  - npm install도 app 폴더 내에서 실행하고 싶은데요.
  - 도커에게 모든 명령이 그 폴더에서 실행되어야 한다고 알려주는 편리한 방법은
  - 여기에서 이 명령을 설정하는 것입니다.
  - 이것은 도커 컨테이너의 작업 디렉토리를 설정하는 `WORKDIR`명령인데요.
  - `/app`으로 설정하도록 하죠.
  - 이것은 도커에게 모든 후속 명령이 `그 폴더 내부`에서 실행될 것임을 알리는 겁니다.

6. `COPY . /app`
  - `COPY . ./`
  - `./`는 도커 컨테이너의 현재 작업 디렉토리를 의미하죠.
  - 절대 경로인 `/app`이라고 설정할 수도 있습니다.
  - 이렇게 하면 파일을 복사할 위치를 명확히 알 수 있다.

7. `CMD node server.js`
  - 마지막 명령은 모든 작업이 완료되면 서버를 시작하라는 겁니다.
  - `RUN node server.js`라고 할 수 있지만, 이건 틀린 겁니다.
  - 이 이미지가 빌드될 때마다 실행되기 때문에
  - 이 명령은 올바르지 않습니다.
  - **매우 중요** 여기에 있는 모든 것은 이미지 설정을 위한 도커에 대한 명령입니다.
  - 자, 이미지는 컨테이너의 템플릿이어야 함을 명심하세요.
  - `이미지`를 실행하는 것이 아니라,
  - `이미지를 기반`으로 `컨테이너`를 실행하는 겁니다.
  - 따라서 이 명령을 사용하여 이미지와 템플릿에서 서버를 시작하려고 시도하지만
  - 우리가 원하는 것이 아닙니다.
  - 모든 종속성을 설치하고, 
  - 거기에다 모든 코드를 포함하고 싶습니다.
  - **하지만 이미지를 기반으로 컨테이너를 시작하는 경우에만 서버를 시작하고 싶은 겁니다.**
  - `하나의 동일한 이미지`에서 `여러 컨테이너`를 시작하면
  - 노드 서버도 여러개 시작되죠.
  - 따라서 이를 위한 또 다른 명령이 있습니다.
  - 이는 CMD 명령입니다.

8. `CMD`
  - RUN과의 차이점은 `이미지가 생성`될 때 실행되지 않고 
  - 이미지를 기반으로 컨테이너가 시작될 때 실행된다는 겁니다.
  - 컨테이너가 실행된 후에 노드 서버를 실행하고자 하는 거죠.
  - 그런데 CMD의 경우, 구문이 약간 다릅니다.
  - 우리는 배열을 전달합니다.
  - 명령을 두 개의 문자열로 분할하는데요.
  - 도커에게 이미지를 기반으로 컨테이너가 `시작`될 때마다
  - 그 컨테이너 내부에 있는 node 명령을 사용하여 
  - server.js 파일을 실행하도록 지시합니다.
  
9. `EXPOSE 80`
  - 도커에 알리는 EXPOSE 80 명령을 추가해야 합니다.
  - 이 컨테이너를 실행할 우리의 로컬 머신에게 말이죠.
  - 그런 후에 이 80 포트를 수신하고 있는 그런 컨테이너를 실행할 수 있게 되는 거죠.
  
## 23. 자체 이미지를 기반으로 컨테이너 실행하기
1. 
  - 여기에 Dockerfile이 있습니다.
  - 이것을 이미지로 변환한 다음
  - 궁극적으로 컨테이너로 변환하는 방법은 무엇일까요?

2. `docker build .`
  - `docker run` 이 아니라
  - `docker build`를 입력해 보죠.
  - 왜냐하면 지금은 이미지를 실행하고 싶지 않으니까요.
  - 지금은 무엇보다도 먼저 이미지를 만들고 싶습니다.
  - 이 Dockerfile의 명령에 따라 이미지를 만들고자 하는데요.
  - `build` 명령으로 그걸 할 수 있습니다.
  - Dockerfile을 기반으로 새 커스텀 이미지를 빌드하도록 도커에게 지시합니다.
  - 이제 Dockerfile을 찾을 수 있는 곳을 도커에게 알려줘야 합니다.
  - `.` 동일한 폴더에 Dockerfile이 존재함을 알립니다.
  - `334837ba6abd`는 `이미지 이름`

3. `docker run 334837ba6abd`
  - 컨테이너가 시작되며 
  - 완료되지 않고 계속 실행되는 것을 볼 수 있습니다.
  - 그 이유는 여기서 실행한 명령이
  - `CMD ["node", "server.js"]`
  - 노드 서버를 시작하기 때문입니다.
  - 노드 서버는 완료되지 않고 진행 중인 프로세스가 되죠.
  - 그래서 컨테이너 또한 실행을 계속 유지됩니다.
  - 컨테이너가 시작될 때, 실행된 명령이 완료되지 않았기 때문이죠.
  - 그렇게 컨테이너는 계속 실행됩니다.

4. 웹사이트가 표시 않됨
  - Dockerfile에서 포트를 노출했음에도 말이죠.
  - 그렇다면 왜 작동하지 않을까요?
  - 여기서 무엇을 할 수 있을까요?

5. `docker stop tender_moore`
  - 우선, 분명히 의도한 대로 작동하지 않으니
  - 이 컨테이너를 종료하겠습니다.
  - 그렇게 하려면 새 터미널을 열고
  - `docker ps`를 실행하여 모든 프로세스를 봅니다.
  - `-a` 없이 docker ps를 실행하면, 현재 실행 중인 프로세스만 표시됩니다.
  - 여기에 우리가 만든 이 이미지를 기반으로 하는 컨테이너 하나 있습니다.
  - 여전히 여기에 실행되고 있죠.
  - 언급한 것 처럼 자동으로 종료되지 않기 때문입니다.
  - 자, 이 컨테이너를 수동으로 정지시켜 보죠.
  - `docker stop tender_moore`
  - 이 컨테이너와 컨테이너 내부에서 실행 중인 노드 서버가 종료됩니다.

6. `docker ps -a`
  - 이 작업이 완료되면 `docker ps`를 다시 실행합니다.
  - 실행 중인 컨테이너는 더 이상 볼 수 없죠.
  - `docker ps -a`를 입력하여 컨테이너를 확인해야 합니다.
  - **종료(Exited)** 되었네요.

7. 
  - 포트 80에서 수신 대기 할 수 없는 이유는 무엇일까요?
  - 여기서 한단계가 빠졌기 때문입니다.
  - Dockerfile에 이 EXPOSE 80 명령이 있지만
  - 실제론 이 명령은 도큐먼테이션 목적으로만 추가되었을 뿐이라는 겁니다.
  - 즉, 아무 것도 하지 않습니다.
  - 도큐먼테이션을 추가하는 것은 모범적인 사례이고,
  - 분명 그를 추가하여 컨테이너 포트를 노출시켜야 합니다만, 
  - 그 외에 추가적으로 할 것이 있습니다.
  - 이 EXPOSE 80 명령을 제거할 수도 있지만,
  - 여전히 정상 작동시킬 수 있다는 걸 보여드리도록 하죠.
  - 이 명령은 100% 여러분의 선택 사항이지만
  - 언급했듯이 추가하는 것을 권장합니다.

8. `docker run -p 3000:80 334837ba6abd`
  - 정말로 중요한 것은 컨테이너를 `docker run`으로 실행할 때 특별한 옵션을 추가해야 한다는 겁니다.
  - 이는 publish를 나타냅니다.
  - 이를 통해 도커에게 어떤 로컬 포트가 있는지 알려줄 수 있습니다.
  - 우리의 `로컬 머신`의 어떤 포트가 
  - 이 내부의 도커 특정 포트에 액세스 할 수 있는지 말입니다.
  - 그리고 그 구문은 다음과 같습니다.
  - `-p` 다음 애플리케이션에 액세스하려는 `로컬 포트`를 지정합니다. 
  - `3000` 여러분 원하는대로 하시면 됩니다.
  - 그런 다음 `:` 콜론
  - 내부 도커 컨테이너 `노츨 포트`를 넣습니다.
  - 이 컨테이너에서는 포트 80을 노출하고 있으니까요.
  - 엔터

9. `localhost:3000`
  - Learn Docker in-depth
  - 도커 심층 학습
  - `로컬 포트` 3000에 publish 되었기 때문에 작도하게 됩니다.

10. 정리
  - 이것이 우리의 첫 번째 커스텀 이미지 입니다.
  - 디폴트 노드 이미지를 기반으로 하여,
  - 우리의 자체 명령어와 자체 노드 앱을 포함하고 있죠.
  - 자신의 이미지를 구축하는 방법,
  - 그 이미지를 컨테이너로 실행하는 방법,
  - 그 컨테이너를 중지하는 방법,
  - 그리고 가장 중요한 것은
  - 이러한 핵심 개념이 함께 작동하는 방식을 이해하는 겁니다.

## 24. EXPOSE & 약간의 유틸리티 기능
1. `EXPOSE 80`
  - 컨테이너의 프로세스가 이 포트를 노출할 것임을 **`문서화`**하는 겁니다.

2. `-p`
  - `-p`를 사용하여 실제 포트를 노출해야 합니다.
  - 기술적으로 `-p`는 포트에서 수신 대기할 때 유일하게 필요한 부분입니다.
  - 하지만 Dockerfile에 `EXPPOSE`를 추가하여 이 동작을 문서화하는 것이 모범적인 사용법입니다.

## 25. 이미지는 읽기 전용!
1. 코드 수정
  - 이미지와 컨테이너가 작동하는 방식과 함께
  - 그를 완전히 이해하는 것이 중요합니다.
  - 이를 위해 노드 애플리케이션 코드에서
  - 코드를 변경하고 싶다고 가정해 보겠습니다.

2. 문제점
  - 변경사항은 반영되지 않음
  - **컨테이너를 다시 시작하기도 했는데요.**
  - `docker ps`
  - `docker stop`
  - `docker run`
  - 이미지가 작동하는 방식을 이해해야 합니다.
  - 이것은 소스 코드인 노드 애플리케이션 코드의 일부임을 명심하세요.
  - 소스 코드를 이미지에 복사하고 
  - 기본적으로 복사한 시점에서 소스 코드의 스냅샷을 만듭니다.

3. 해결책
  - 업데이트된 소스 코드를 새 이미지로 복사하려면
  - **이미지를 다시 빌드해야 합니다.**
  - 자, 이것은 정말 중요합니다.

4. 좋은 소식
  - 코드를 변경할 때마다
  - 이미지를 다시 작성해야 한다는 게
  - 번거롭고 이상하게 들린다면
  - 제가 좋은 소식을 알려드리죠.
  - 나중에 코드에서 변경 사항을 선택하는 
  - 더 우아하고 빠른 방법을 배우게 될 겁니다.
  - 그러나 여기에서 핵심을 취하는 것이 중요하며
  - 이것이 진실입니다.

5. 이미지의 읽기 전용
  - 이미지는 기본적으로 잠겨 있고,
  - 일단 빌드되면 끝이라는 거죠.
  - **이미지의 모든 것이 `읽기 전용`이며**
  - 과거에 해당 코드를 복사했기 때문에
  - 단순히 코드를 업데이트하여 외부에서 편집할 수 없습니다.
  - 이미지는 지난 것에 대해 관심이 없습니다.
  - 이미지는 영향을 받지 않습니다.

6. 이미지를 다시 빌드
  - 외부 변경 사항을 집어내어 
  - 업데이트된 모든 코드를 기본적으로 이미지에 복사하려면
  - 이미지를 다시 빌드해야 합니다.

7. `docker build .`
  - 이제 완전히 새로운 이미지니까요.
  - 이전과 거의 동일하지만, 
  - 완전히 다른 코드입니다.

8. 이미지
  - 이미지가 결국 닫힌 템플릿이라는 것을
  - 이해하는 것이 매우 중요하기 때문에
  - 저는 그것에 대해 매우 강조하고 있습니다.

9. Dockerfile
  - 이러한 명령어는 이미지를 생성하기 위해 실행되고,
  - 그 후에는 잠겨서 완료됩니다.
  - 그 후에 이미지에 복사된 것을 변경해도 아무런 영향이 없습니다.

## 26. 이미지 레이어 이해하기
1. `레이어 기반`
  - 이미지를 빌드하거나 
  - 이미지를 다시 빌드할 때
  - 변경된 부분의 명령과 그 이후의 모든 명령이
  - 재평가된다는 의미입니다.

2. `Using cache`
  - 코드를 변경한 다음
  - 이 이미지를 다시 작성했음을 기억하세요.
  - `docker build .`
  - 다시 발드하면
  - 4분의 1초 만에 끝난 거 같네요.
  - `Using cache` (캐쉬 사용)이라는 메시지를 볼 수 있죠.
  - 도커는 실제로 그 명령을 다시 거칠 필요가 없다고 추론한 겁니다.

3. `레이어 기반 아키텍쳐`
  - 대신 이미지를 빌드할 때마다
  - 도커는 모든 명령 결과를 캐시하고 
  - 이미지를 다시 빌드할 때
  - 명령을 다시 실행할 필요가 없으면
  - 이러한 `캐시된 결과`를 사용합니다.
  - 이것을 `레이어 기반 아키텍처` 라고 합니다.

4. `새 이미지 생성`
  - **모든 명령은 `Dockerfile`의 레이어를 나타냅니다.**
  - 그리고 이미지는 이러한 다양한 명령을 기반으로 
  - 여러 레이어에서 간단하게 구성됩니다.
  - 또한 이미지는 읽기 전용입니다.
  - 즉, 일단 명령이 실행되고 이미지가 빌드되면
  - 이미지가 잠기고, 이미지를 다시 빌드하지 않는 한 
  - 그 코드를 변경할 수 없습니다.
  - 이는 기술적으로 새 이미지를 생성한다는 의미입니다.

5. `캐시`
  - 모든 명령어를 기반으로 하는 이미지 레이어는
  - 레이어를 생성하고, 이러한 레이어는 캐시됩니다.
  - 그런 다음 이미지를 기반으로 컨테이너를 실행하면
  - 그 컨테이너는 기본적으로
  - Dockerfile에 지정한 명령을 실행한 결과로
  - 코드를 실행 중인 애플리케이션인 이미지 위에 
  - 새로운 추가 레이어를 추가합니다.

6. `하나의 파일이 변경된 것을 알아차림`
  - `COPY . /app` 
  - 모든 파일을 다시 복사한다.
  - 여기서 중요한 것이 있습니다.
  - 하나의 레이어가 변경될 때마다
  - 다른 모든 레이어가 다시 빌드된다고 말했습니다.
  - **레이어 변경 후의 모든 레이어**
  - `RUN npm install` 도 수행한다.
  - 이 레이어 기반 아키텍처가 명확히 이해되셨기를 바랍니다.

7. `유용한 메커니즘`
  - 도커는 다시 실행해야 하는 항목만 다시 빌드하여
  - 다시 실행하여, 이미지 생성 속도를 높이기 위해 존재합니다.
  - 물론 이것은 매우 유용한 메커니즘입니다.

8. `package.json`
  - 프로젝트의 종속성을 관리하는 `package.json`에서
  - 무언가를 변경하지 않는 한
  - npm install을 다시 실행할 필요가 없죠.
  - 소스 코드에서 무언가를 변경한 경우
  - 이 프로젝트에 필요한 종속성에 영향을 미치지 않으므로
  - 노드 세계에서 npm install을 다시 실행할 필요가 없습니다.

9. `최적화`
  - Dockerfile에서 최적화 가능성의 첫 번째 부분이 있습니다.
  - 이렇게 모두 `복사`한 다음 `npm install`을 실행하는 대신
  - `npm install` 후에 모두를 복사한다.
  - 다시 실행하는 것보다 성능이 더 좋을 겁니다.

10. 변경 확인 및 중지
  - `docker run -p 3000:80 20a1ee60b392`
  - `docker ps`
  - `docker stop lucid_napier`

## 27. 첫 번째 요약
1. 스텐드얼론
  - 여러분이 배운 컨테이너는 이미지 위에 추가된 `얇은 레이어`일 뿐입니다.
  - 하지만 여전히 컨테이너는 이미지를 기반으로 하는 실행 애플리케이션입니다.
  - 일단 실행되면 실행 중인 다른 컨테이너와는 `독립적인 스탠드얼론`이죠.

2. `이미지`와 `컨테이너`
  - 컨테이너가 이미지에서 코드와 환경을 새 컨테이너로 복사하거나
  - 새 파일로 복사하지 않는다는 겁니다.
  - 그런 일은 벌어지지 않습니다.
  - **컨테이너는 `이미지에 저장된 환경`을 사용합니다.**
  - 그런 다음 그 위에 이 부가 레이어를 추가합니다.
  - 예를 들어 이 실행 중인 노드 서버 프로세스는 
  - 애플리케이션을 실행하기 위해 
  - 리소스, 메모리 등을 할당합니다.
  - **하지만 코드를 복사하지는 않습니다.**
  - 따라서 우리의 코드와 노드 환경은 여기에서 세 번이나 복사되지는 않는 거죠.
  - 하나의 이미지와 두 개의 컨테이너가 있는 경우
  - 이미지와 컨테이너에 한 번만 존재하므로
  - 그 이미지와 그 안의 코드를 활용합니다.
  - 이것이 도커가 이를 관리하는 방법이며
  - 물론 매우 효율적입니다.
  - **이것이 `도커의 핵심 아이디어`죠**
  - 앱을 포함하는 격리된 환경과 
  - 그 앱을 실행하는데 필요한 모든 것, 모든 환경, 
  - node js와 같은 모든 도구, 
  - 그런한 것을 이 격리된 컨테이너 내부에 모두 포함하는 것.

## 퀴즈 1: Image & Containers
1. `이미지`란 무엇인가요?
  - 이미지는 읽기/쓰기 액세스 권한이 있는 인스턴스를 실행하는 컨테이너의 "블루프린트"입니다.

2. `이미지`와 `컨테이너`가 있는 이유는 무엇인가요? `컨테이너`만으로는 왜 안될까요?
  - 이 개념을 통해, 여러 컨테이너가 서로 간섭하지 않고 동일한 이미지를 기반으로 할 수 있습니다.
  - 여러 컨테이너가 동일한 이미지를 기반으로 할 수 있지만, 서로 완전히 격리되어 있습니다.

3. 컨테이너와 관련하여 `격리`는 무엇을 의미하나요?
  - 컨테이너는 서로 분리되어 있으며, 디폴트로 공유 데이터나 상태가 없습니다.

4. `컨테이너`란 무엇일까요?
  - 이미지를 기반으로 하는 격리된 소프트웨어 유닛입니다. 이미지의 실행 중인 인스턴스입니다.

5. 이미지의 내부 내용(context)에서 `레이어`란 무엇인가요?
  - 이미지의 모든 명령은 캐시 가능한 레이어를 생성합니다. 레이어는 이미지 재구축 및 공유를 돕습니다.

6. 이 명령은 무엇을 하나요? `docker build .`
  - 이미지를 구축합니다.

7. 이 명령은 무엇을 하나요? `docker run node`
  - `node` 이미지를 기반으로 컨테이너를 만들어 실행합니다.
  - 이미지가 로컬에 없으면 DockerHub에서 찾으려 시도 합니다.

## 28. 이미지 & 컨테이너 관리
1. `--help`
  - 사용 가능한 모든 옵션을 볼 수 있다는 겁니다.

2. 핵심 구성 옵션과 핵심 기능
  
3. `이미지`
  - `태그를 다는 방법`을 배울 건데요.
  - 기본적으로 이미지를 명명하는 것을 의미하죠.
  - 과거에 만든 이미지를 나열하는 방법을 배우고,
  - 이미지를 분석하고 검사하는 방법
  - 이미지를 제거하고 지우는 방법

4. `컨테이너`
  - 컨테이너 이름을 지정하는 방법
  - 컨테이너를 세부적으로 구성하는 방법
  - 컨테이너 리스팅,
  - 실행 및 중지된 컨테이너에 대해 다시 살펴보구요.
  - 이전에 중지한 컨테이너를 다시 시작하는 방법
  - 컨테이너 중지한 후, 그 컨테이너를 제거하는 방법

## 29. 컨테이너 중지 & 재시작
1. `docker --help`
  - 내장된 메인 명령 목록을 얻을 수 있습니다.

2. `이미지`와 `컨테이너`관리부터 시작하고자 합니다.
  - 그게 도커의 모든 것이니까요.

3. `docker ps`
  - 모든 `컨테이너`를 리스트 할 수 있다.
  - 실행 중인 모든 컨테이너를 디폴트로 보여준다.

4. `docker ps -a`
  - 더 이상 실행되지 않는 중지된 컨테이너를 포함하여
  - 과거에 있었던 모든 컨테이너가 표시 됩니다.

5. `docker ps --help`
  - docker ps에 사용 가능한 모든 구성 옵션이 표시됩니다.

6. `docker ps -a`
  - 새 컨테이너를 항상 `docker run`으로 실행할 필요는 없습니다.
  - `docker run`은 이미지를 기반으로 새 컨테이너를 만들고
  - 그 이후에 `새 컨테이너`가 시작됩니다.
  - 애플리케이션, 종속성 및 소스 코드가 변경되지 않고
  - 이미지가 변경되지 않은 경우
  - 완전히 새로운 컨테이너를 생성할 필요가 없죠.
  - 기존 컨테이너를 다시 시작할 수 있습니다.
  - `docker ps -a`

7. `docker start`
  - `docer start priceless_saha`
  - `docker start` 다음, 컨테이너 ID 또는 이름을 입력하여
  - 실행하면 컨테이너가 백업됩니다.
  - 이제 다른 모드에서 컨테이너를 시작하는 것을 볼 수 있습니다.
  - `docker run`과 같이 터미널을 차단하지는 않지만
  - 이 컨테이너는 실행 중이라고 할 수 있죠.

8. `docker run`과는 다릅니다.

## 30. Attached & Detached 컨테이너 이해하기
1. `백그라운드 실행`

2. `docker run -p 8000:80 2ddf2edeb6c`
  - 이 프로세스에서 막힌 것을 알 수 있습니다.
  - 더 이상의 명령을 입력할 수 없죠.
  - Enter키를 눌러 실행할 수 없습니다.

3. `docker start`
  - `docker start`는 그렇지 않죠.
  - 자, 이것은 강제 당하는 것이 아닙니다.
  - attached(연결) 모드나, detached(분리)모드를 
  - 여러분이 원하는대로 설정할 수 있습니다.

4. `detached` 모드
  - `docker start`로 시작하는 경우, detached 모드가 디폴터이며,
  - `docker run`으로 실행하는 경우, attached 모드가 디폴트 입니다.

5. `docker run -p 8000:80 -d 2ddf2ecde7d6c`
  - 이미지 ID 앞에 부가 플래그로 -d를 추가하여
  - detached 모드로 해 보겠습니다.
  - 자동으로 생성된 `새 컨테이너`의 ID를 얻습니다.

6. `docker attach eloquent_brown`
  - 실행 중인 컨테이너를 계속 보고 싶다면
  - 두 가지 방법이 있습니다.
  - `docker --help`
  - `attach` 명령입니다.

7. `docker logs eloquent_brown`
  - `docker ps`
  - 먼저 컨테이너를 찾습니다.
  - `docker logs eloquent_brown`
  - `docker logs -f eloquent_brown`

8. 정리
  - 연결되어 있든, 분리되었든 그에 상관없이
  - 여전히 실행 중입니다.
  - 하지만 컨테이너 내부의 정보가 필요한 경우,
  - `docker logs`를 사용하거나
  - 컨테이너를 다시 직접 연결하여
  - 추가 정보를 얻을 수 있습니다.

9. 컨테이너 중지 및 재시작
  - `docker stop eloquent_brown`
  - `docker start -a eloquent_brown`

## 31. 이미 실행 중인 컨테이너에 연결하기
1. `-d`
  - 디폴트로 `-d` 없이 컨테이너를 실행하면 `attached모드`로 실행됩니다.
  - detached모드로 컨테이너를 시작한 경우에는 다음 명령을 사용하여 컨테이너를 
  - 다시 시작 하지 않고도 컨테이너에 연결할 수 있습니다.
  - 이는 CONTAINER라는 ID 또는 이름으로 실행 중인 컨테이너에 연결합니다.

## 32. 인터렉티브 모드로 들어가기
1. 두 가지 이유
  - 도커가 노드와 웹 서버에 관한 것만이 아니다.
  - 컨테이너 `연결(attached)` 및 `분리(detached)`와 관련이 있습니다.
  - 컨테이너는 전면과 배경에서 실행됩니다.

2. 상호작용
  - 이 앱은 실제로 사용자가 앱과 상호 작용해야 하기 때문이죠.

3. 도커화(Dockerize)
  - 단계별로 도커화(Dockerize)를 해 봅시다.

4. Dockerfile
  - Python을 `베이스 이미지`로 사용하는 `커스텀 이미지`를 만들어야겠죠.
  - Docker Hub의 `Python 이미지`를 찾을 수 있습니다.
  - 이것이 컨테이너를 시작할 때 
  - 시작되어야 하는 명령이구요.

5. `docker build .`
  - 이미지를 빌드해 보자
  - `Python 베이스 이미지`도 다운로드 합니다.

6. `docker run e65dca5ecb69`
  - docker run을 실행하여 컨테이너를 불러올 수 있습니다.

7. `EOFError`
  - 우리는 무엇이든 입력할 수 있다는 견지에서
  - 연결을 한 것이 아닙니다.
  - 컨테이너나 컨테이너로 실행되는 애플리케이션에는 
  - 그 어떤 것도 입력할 수 없거든요.

8. `docker run --help`
  - `-i`, `--interactive`
  - 컨테이너에 무언가를 입력할 수 있습니다.

9. `-t`
  - 그러나 일반적으로 이것을 `-t`와 결합하면
  - `pseudo` TTY가 할당 되는데요.
  - 이것은 터미널을 생성한다는 것을 의미합니다.
  - 따라서 i와 t 플래그를 결합하면
  - 무언가를 입력할 수 있게 되죠.
  - 따라서 컨테이너는 입력을 수신하고
  - 컨테이너에 의해 노출되는 터미널도 얻게 됩니다.
  - 컨테이너는 실제로 입력을 받는 장치가 되는 거죠.

10. `-i -t` `-it`
  - `docker run -it e65dca5ca5ecb69`
  - 이제 이것으로 충돌하지 않는 것을 볼 수 있습니다.
  - 터미널에 무언가를 입력할 수 있습니다.

11. 컨테이너가 종료된 후, 더 이상 실행되지 않는 것을 볼 수 있죠.
  - `-a`로 확인해 보면 종료되었습니다.

12. `docker start heuristic_haslett`
  - 재실행 되었지만, 문제가 생겼습니다.
  - docker start는 디폴트로 `detached 모드`이기에 
  - 컨테이너와 통신할 수 없죠.

13. 두가지 해결 방법
  - `docker start -a heuristic_haslett`
  - `docker stop heuristic_haslett`

14. 다른 방법 (interactive) 
  - `docker start --help`
  - 출력을 수신하기 위해 `-a`만 있는 것이 아니라
  - `-i`를 통해 컨테이너에 무언가를 입력할 수 있다는 걸 알 수 있습니다.
  - 이제 여기에 `-t` 플래그가 필요하지 않습니다.
  - 처음에 그 플래그로 컨테이너를 실행하고
  - `docker run`명령을 사용하여
  - 다시 컨테이너를 실행한다면 그 플래그가 여전히 기억되기 때문입니다.
  - 하지만 여기서 다시 시작한다면
  - 출력 결과를 수신하고 싶다는 것을 다시 강조해야 합니다.
  - `docker start -a -i heuristic_haslett`

15. 정리
  - 출력 결과를 수신하기 위해 연결할 뿐만 아니라
  - 입력을 제공하기 위해 연결하는 이유는
  - 도커가 웹 서버와 웹 애플리케이션 같은
  - 장기적인 실행 프로세스에만 적용되는 게 아니기 때문입니다.
  - 도커는 간단한 유틸리티 애플리케이션을 도커화하는데에도 사용할 수 있습니다.
  - 이와 같이 입력이 필요하고,
  - 일부 출력을 제공하는 애플리케이션을 만들 수 있죠.
  - 이 또한 도커를 사용할 수 있는 사례이며, 이것이 도커를 사용하는 방법이죠.

## 33. 이미지 & 컨테이너 삭제하기
1. `docker rm`
  - 더 이상 필요하지 않은 이미지와 컨테이너를 
  - 관리하는 것으로 시작해 보도록 하죠.

2. `docker rm eloquent_brown`
  - You cannot remove a running container
  - `docker stop eloquent_brown`
  - `docker stop exciting_elgamal`
  - `docker rm mystifying_dijkstra ecstatic`
  - `docker ps -a`

3. 더 우아하고 쉬운 방법
  - `docker images`
  - 노드 이미지 빌드에 이들 툴과 운영체제 이미지가 추가된 크기입니다.
  - 하지만 그래도 일종의 노드인 거죠.

4. `docker rmi 334837`
  - 이미지 제거를 위한 rmi
  - `docker rmi 334837`
  - 기본적으로 이미지 내부의 모든 레이어를 삭제합니다.

5. `이미지 제거`
  - 이미지 제거에 대한 한 가지 중요한 참고 사항은
  - 이미지가 더 이상 컨테이너에서 사용되지 않고
  - 중지된 컨테이너에 포함된 경우에만 이미지를 제거할 수 있다는 겁니다.
  - 중지된 컨테이너가 있는 경우 그 컨테이너에서 사용 중인 이미지를 제거할 수 없습니다.
  - `먼저 그 컨테이너를 제거` 해야 합니다.
  - 즉, 컨테이너가 시작되거나 중지되더라도 
  - 그 컨테이너에 속한 이미지는 제거할 수 없습니다.
  - **우선적으로 컨테이너를 제거해야 합니다**

6. `docker image prune`
  - 현재 실행 중인 컨테이너에서 사용되지 않는
  - 모든 이미지를 제거하기 위해
  - `docker image prune`
  - 이것은 사용되지 않는 모든 이미지를 제거합니다.
  - `docker images`

## 34. 중지된 컨테이너 자동 제거하기
1. `docker run --help`

2. `docker run -p 3000:80 -d --rm 2ddf2ede`
  - `--rm` 플래그
  - 이것은 컨테이너가 종료될 때 자동으로 제거되는 플래그인데요.
  - 이것은 매우 유용합니다.
  - 매번 중지된 모든 컨테이너를 수동으로 정리하지 않아도 되죠.
  - 대신 이 컨테이너가 중지될 때마다
  - 자동으로 제거되도록 하기 위해
  - run 명령에 이걸 간단히 추가하면 됩니다.

3. `docker stop crazy_euclid`
  - `docker ps -a`
  - 컨테이너가 중지 되었을 때 자동으로 제거할 수 있습니다.

## 35. 작동 배경 살펴보기: 이미지 검사
1. `docker images`
  - 이 이미지에는 코드와 애플리케이션 환경이 포함되어 있습니다.
  - 그래서인지 꽤 큽니다.
  - 실행 중인 `컨테이너`는 실제로 크렇게 크지 않고,
  - `명령 레이어`가 이미지 위에 추가된 얇은 `부가 레이어`입니다.
  - 따라서 이 이미지 코드는 실행 중인 `컨테이너`에서 사용됩니다.
  - 이것은 다시 복사되지 않습니다.

2. 컨테이너
  - 컨테이너는 이미지를 기반으로 빌드되고,
  - 동일한 이미지를 기반으로 실행되는 
  - 여러 컨테이너는 이미지 내부의 코드를 공유합니다.
  - 그렇기 때문에 이미지 내부의 이 코드도 잠겨 있습니다.
  - 읽기 전용 컨테이너만 변경할 수 있습니다.

3. 얇은 부가 컨테이너 레이어
  - 예를 들어, 모든 이미지 레이어 위에 추가된
  - 새로운 얇은 `부가 컨테이너` 레이어 내부에 파일을 만듭니다.
  - 그것이 작동하는 방식인데요.

4. `docker image inspect 2ddf2ede7d6c`
  - 이미지에 대해 더 알고 싶다면 그에 대한 명령도 있습니다.
  - 이미지에 대한 정보가 포함된 긴 출력 결과가 표시됩니다.

## 36. 컨테이너에/컨테이너로 부터 파일 복사하기
1. `docker cp`
  - 복사(copy)를 의미하는 cp명령입니다.
  - `실행 중인 컨테이너`로 또는 실행 중인 `컨테이너 밖`으로
  - 파일 또는 폴더를 복사할 수 있습니다.

2. 복사하기
  - dummy/test.txt
  - `docker cp` 우선 소스를 지정합니다.
  - 즉, 다른 위치에 복사하려는 폴더나 파일이죠.
  - `docker cp dummy/. boring_vaughan:/test`

3. 예를 들어
  - 변경하려는 웹 서버의 구성 파일 같은 경우 말이죠.
  - 컨테이너가 많은 로그 파일을 생성하는 경우
  - `docker cp`로 이러한 로그 파일을 컨테이너에서 `로컬 호스트 시스템`으로 
  - 복사할 수 있으니까요.
  - 그러면 로그 파일에 직접 접근할 수 있겠죠.

## 37. 컨테이너와 이미지에 이름 지정 & 태그 지정하기
1. 이미지
  - 이미지와 컨테이너의 이름을 지정하는 옵션입니다.
  - `docker images`

2. 컨테이너
  - `docker ps`
  - 자동으로 생성된 이름이 있는 것을 볼 수 있습니다.
  - 물론 없는 것보다는 낫지만

3. 컨테이너에 이름 지정
  - `docker run --help`
  - `--name` 옵션은 컨테이너에 이름을 추가하는 거네요.
  - 이것이 우리가 필요한 내용입니다.
  - `docker run -p 3000:80 -d --rm --name goalsapp 2ddf2ede7d6c`
  - `docker os`
  - `docker stop goalsapp`
  - `docker ps -a`

4. 이미지에 이름 지정 (`태그`)
  - 예를 들어 이미지에 이름을 지정할 수도 있습니다.
  - 이를 `태그`라고 부릅니다.

5. 이미지 태그 구성
  - 실제로 `이미지 태그`는 두 부분으로 구성됩니다.
  - name (이름): 이미지의 리포지터리라고도 합니다.
  - tag (태그): 콜론으로 구분됩니다.
  - 이 두 부분으로 나눈 컨셉은 간다난 이유 때문입니다.

6. `이름 (name)`
  - 이름을 사용하여 이미지의 일반적인 이름을 설정할 수 있습니다.
  - 정확히 말하면
  - 여러 개의 특정화된 이미지 그룹을 만들 수 있습니다.
  - 예를 들어, 우리가 가져온 `node` 이미지 말입니다.

7. `태그 (tag)`
  - 태그도 가지고 있는데요.
  - 언급했듯이 그것은 옵션입니다.
  - 그 이미지의 보다 `특정화된 버전`을 정의할 수 있습니다.
  - 특정 버전의 노드 이미지를 사용하는 거죠.
  - 이미지를 포함하는 NodeJS에 관한 모든 겁니다.

8. 고유 식별자
  - 이름을 태그와 결합할 수 있습니다.
  - 고유 식별자를 언제나 가지게 됩니다.

9. `docer build --help`
  - `-t` 옵션 - 이름:태그 형식으로 이름과 태그를 추가할 수 있네요.
  - `docker build -t goals:latest .`

10. `docker run -p 3000:80 --rm --name goalsapp goals:latest`
  - 이미지 ID 대신, 그 태그를 여기에 연결할 수 있습니다.
  - 여기에 제공된 이름과 태그 조합으로 실행됩니다.

11. 중지
  - `docker stop goalsapp`

## 38. 이미지 공유하기 - 개요
1. 이점
  - 도커와 컨테이너를 사용하면 많은 이점을 얻을 수 있습니다.
  - 항상 로컬 종속성을 언인스톨하고, 재설치할 필요가 없었죠.
  - 대신, 예를 들어 할당 `애플리케이션`에서 이미 도커를 사용하고 있지만
  - 이 모듈 이전에 구축한 애플리케이션에서도 도커를 사용하고 있습니다.

2. 버전 관리
  - 우리의 컴퓨터에 수많은 다양한 프로젝트를 가질 수 있는데
  - 다양한 의존성과 다양한 버전에 요구되기에
  - 항상 다양한 도구를 제거하거나, 다시 설치하지 않고도 같이 공존할 수 있습니다.

3. `공유`
  - 다른 사람들과 공유하기 위해 도커를 사용하고 있습니다.
  - 같은 프로젝트에 참여하는 팀원일 수도 있고,
  - 또는 컨테이너를 배포하려는 `서버`일 수도 있습니다.

4. 이미지를 공유
  - 이미지를 공유할 때, 두 가지 주요 방식이 있습니다.
  - `Dockerfile`을 공유할 수 있는데요.
  - `빌드된 전체 이미지`를 공유할 수 있습니다.

## 39. DockerHub에 이미지 푸시(push)하기
1. `두가지 주요 위치`
  - `도커 허브`
  - `개인 레지스트리`
  
2. `도커 허브`
  - 도커 허브는 간단하게 말하면 공식 도커 이미지 레지스트리입니다.
  - 하지만 들어오는 이미지를 처리하는 방법과 이미지를 저장하고
  - 배포하는데 사용할 수 있는 수천 개의 다른 서비스가 있습니다.
  - 나중에 배포를 하게 되면,
  - 개인 레지스트리를 더 많이 활용하는 것을 보게 될 겁니다.
  - 하지만 당분간은 `도커 허브`를 사용하겠습니다.
  - 무료로 사용할 수 있거든요.

3. `push`와 `pull`
  - 푸시 및 풀 명령에 해당 공급자의 URL이 포함되어야 합니다.

4. 레포지토리 
  - 공유 이미지는 결국 저장소일 뿐입니다.
  - Create Repository > node-hello-world > Create

5. 중요
  - `docker push academind/node-hello-world`
  - 그러면 로컬에 존재하지 않는 저장소를 
  - 참조하고 있다는 걸 알아차릴 수 있습니다.
  - **그건 중요한 건데요.**
  - 로컬에 존재하지 않습니다.

6. 도커에게 알려주기
  - 도커에게 알려주는 것은 간단합니다.
  - 이상하게 보일 수 있지만
  - 이미지에 이 이름을 지정하기만 하면 됩니다.
  - **도커 ID를 접두사로 지닌 이름이 됩니다.**

7. 새 이미지
  - 도커 허브에 푸시하는 이미지로 바꾸고자 합니다.
  - 두가지 방법이 있습니다.
  - `cd node-app`
  - `docker build -t academind/node-hello-world .`
  - 적절한 이름으로 새 이미지를 생성합니다.

8. 기존 이미지 변경
  - 사용하려는 이미지가 이미 있는 경우, 
  - `docker tag node-demo:latest academind/node-hello-world:lastest`
  - `docker tag node-demo:latest academind/node-hello-world`
  - 우리는 그냥 이름만으로 하도록 하죠.

9. `docker images`
  - 이미지 이름을 바꾸면, 이전 이미지가 제거되지 않습니다.
  - 대신 이전 이미지의 복제본을 생성합니다.
  - 우리에게 필요한 이름의 복제본이죠.

10. push
  - `docker push academind/node-hello-world`
  - 그러나 여기에도 액세스 거부 메시지가 표시됩니다.
  - 이걸 보도록 하죠.
  
11. `docker login`
  - 이것을 한 번 실행하면 로그인 상태가 유지됩니다.
  - academind
  - 비밀번호
  - Login Succeeded

12. 
  - 이 이미지를 이전에 생성한 도커 허브의 리포지터리로 푸시하고 있습니다.
  - **전체 이미지를 업로드 하지 않습니다.**
  - 그대신, 예를 들어 우리가 노드 이미지에 의존하고 있음을 알 수 있는데요.
  - `그건 이미 도커 허브에 있죠.`
  - 따라서 그 노드 이미지에 대한 연결을 설정하여
  - 필요한 추가 코드만 푸시합니다.
  - **즉, 전체 노드 이미지가 아닌 `추가 정보만` 푸시하는 거죠.**

13. 절약
  - 도커 허브에서는 공간을 절약하고, 
  - 저는 대역폭을 절약하니까요.

## 40. 공유 이미지 가져오기(pull) & 사용하기
1. `docker image prune -a`
  - 모든 로컬 이미지를 삭제하겠습니다.
  - `docker images`

2. 컨테이너 걸려 있는 이미지 삭제
  - 그냥 두자

3. `docker pull`
  - 이미지를 다운로드 할 수 있다는 겁니다.
  - `docker logout`
  - `docker pull academind/node-hello-world`

4. `docker run -p 8000:3000 --rm academind/node-hello-world`

5. `docker ps`
  - `docker stop clever_image`

6. `docker run academind/node-hello-world`
  - `docker run`은 로컬 컴퓨터에서 이미지를 찾지 못하면
  - 이미지 이름이 사용한 컨테이너 히스토리에 자동으로 접근합니다.
  - 그래서 이 경우 `Docker Hub`이기에 거기에서 이미지를 확인합니다.
  - 그리고 거기에서 해당 이름의 이미지를 찾으면 
  - 그 이미지를 사용하여 자동으로 풀링합니다.
  - 업데이트를 위해 자동으로 체크한다는 것이 중요합니다.
  - 

7. `docker pull`
  - `docker run`만으로는 최신 업데이트 이미지를 제공받지 못 합니다.
  - 수동으로 `docker pull`과 이미지 이름을 입력하여 실행해야 합니다.
  - 그런 다음 `docker run`을 다시 실행합니다.
  - `docker run`은 로컬 시스템에 찾는 이미지가 없다면
  - 히스토리를 검색해 자동으로 이미지를 풀링하지만
  - 로컬 시스템이 찾는 이미지가 있다면, 
  - **그게 최신 버전인지 아닌지 상관없이 풀링하지 않고 그걸 사용합니다.**

## 퀴즈 2: Managing Images & Containers
1. 이 명령의 결과는 무엇인가요?
  - `docker build -t myimage .`
  - `docker run --name mycontainer myimage`
  - `docker stop mycontainer`
  - 이미지가 생성되고, 컨테이너가 시작된 다음, 중지됩니다.
  - 이미지와 컨테이너 모두 개발자가 지정한 이름이 있습니다.

2. 다음 명령이 실행되었다고 가정합니다.
  - `docker build -t myimage:latest . `
  - `docker run --name mycontainer --rm myimage`
  - `docker stop mycontainer`
  - `docker stop mycontainer`가 실패합니다. 중지되면 자동으로 제거되기 때문에, 그러한 컨테이너는 없을 겁니다.

3. 이미지 태그의 배경 사상은 무엇일까요?
  - 이미지에는 이름이 있을 수 있으며, 그 이미지의 여러 '버전'이 같은 이름에 첨부될 수 있습니다.
  - node:14를 생각해 봅시다. node 이미지 (NodeJS 설정 포함)와 그 이미지의 v14 특정 버전을 뜻합니다.

4. 커스텀 이미지 태그와 컨테이너 이름을 할당해야 하나요?
  - 아니요. Docker는 이름과 ID를 자동으로 할당합니다.
  - 이름을 자체적으로 정할 수 있지만, 그렇지 않으면 Docker가 이름과 ID를 자동 할당합니다.

## 41. 모듈 요약
1. 도커는 이미지와 컨테이너에 관한 모든 것이라는 점입니다.

2. 이미지는 템플릿, 컨테이너의 블루프린트이며

3. 하나의 동일한 이미지를 기반으로 하는 여러 컨테이너를 실행할 수 있으며,

4. 컨테이너가 아닌 이미지에 저장된 코드와 환경을 사용하여 이미지의 도움으로 설정 및 구성된 애플리케이션을 실행합니다.

5. 이미지와 컨테이너 간에 작업이 이런 식으로 분할되죠.

## 42. 모듈 리소스




